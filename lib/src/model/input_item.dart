//
// AUTO-GENERATED FILE, DO NOT MODIFY!
//

// ignore_for_file: unused_element
import 'package:openai_flutter_sdk/src/model/mcp_list_tools_tool.dart';
import 'package:openai_flutter_sdk/src/model/reasoning_item_summary_inner.dart';
import 'package:openai_flutter_sdk/src/model/local_shell_exec_action.dart';
import 'package:built_collection/built_collection.dart';
import 'package:openai_flutter_sdk/src/model/code_interpreter_tool_call_outputs_inner.dart';
import 'package:openai_flutter_sdk/src/model/easy_input_message.dart';
import 'package:openai_flutter_sdk/src/model/item.dart';
import 'package:openai_flutter_sdk/src/model/computer_tool_call_safety_check.dart';
import 'package:openai_flutter_sdk/src/model/item_reference_param.dart';
import 'package:openai_flutter_sdk/src/model/file_search_tool_call_results_inner.dart';
import 'package:openai_flutter_sdk/src/model/output_content.dart';
import 'package:openai_flutter_sdk/src/model/computer_call_safety_check_param.dart';
import 'package:built_value/built_value.dart';
import 'package:built_value/serializer.dart';
import 'package:one_of/one_of.dart';

part 'input_item.g.dart';

/// InputItem
///
/// Properties:
/// * [role] - The role of the output message. Always `assistant`. 
/// * [content] - The content of the output message. 
/// * [type] - The type of the message input. Always `message`. 
/// * [status] - The status of the item. One of `in_progress`, `completed`, or `incomplete`. 
/// * [id] - The ID of the item to reference.
/// * [queries] - The queries used to search for files. 
/// * [results] - The results of the file search tool call. 
/// * [callId] - The unique ID of the local shell tool call generated by the model. 
/// * [action] 
/// * [pendingSafetyChecks] - The pending safety checks for the computer call. 
/// * [output] - The output from the tool call. 
/// * [acknowledgedSafetyChecks] - The safety checks reported by the API that have been acknowledged by the developer.
/// * [name] - The name of the tool that was run. 
/// * [arguments] - A JSON string of the arguments passed to the tool. 
/// * [encryptedContent] - The encrypted content of the reasoning item - populated when a response is generated with `reasoning.encrypted_content` in the `include` parameter. 
/// * [summary] - Reasoning text contents. 
/// * [result] - The generated image encoded in base64. 
/// * [containerId] - The ID of the container used to run the code. 
/// * [code] - The code to run, or null if not available. 
/// * [outputs] - The outputs generated by the code interpreter, such as logs or images.  Can be null if no outputs are available. 
/// * [serverLabel] - The label of the MCP server running the tool. 
/// * [tools] - The tools available on the server. 
/// * [error] - The error from the tool call, if any. 
/// * [approvalRequestId] - The ID of the approval request being answered. 
/// * [approve] - Whether the request was approved. 
/// * [reason] - Optional reason for the decision. 
@BuiltValue()
abstract class InputItem implements Built<InputItem, InputItemBuilder> {
  /// One Of [EasyInputMessage], [Item], [ItemReferenceParam]
  OneOf get oneOf;

  static const String discriminatorFieldName = r'type';

  static const Map<String, Type> discriminatorMapping = {
    r'EasyInputMessage': EasyInputMessage,
    r'Item': Item,
    r'ItemReferenceParam': ItemReferenceParam,
  };

  InputItem._();

  factory InputItem([void updates(InputItemBuilder b)]) = _$InputItem;

  @BuiltValueHook(initializeBuilder: true)
  static void _defaults(InputItemBuilder b) => b;

  @BuiltValueSerializer(custom: true)
  static Serializer<InputItem> get serializer => _$InputItemSerializer();
}

extension InputItemDiscriminatorExt on InputItem {
    String? get discriminatorValue {
        if (this is EasyInputMessage) {
            return r'EasyInputMessage';
        }
        if (this is Item) {
            return r'Item';
        }
        if (this is ItemReferenceParam) {
            return r'ItemReferenceParam';
        }
        return null;
    }
}
extension InputItemBuilderDiscriminatorExt on InputItemBuilder {
    String? get discriminatorValue {
        if (this is EasyInputMessageBuilder) {
            return r'EasyInputMessage';
        }
        if (this is ItemBuilder) {
            return r'Item';
        }
        if (this is ItemReferenceParamBuilder) {
            return r'ItemReferenceParam';
        }
        return null;
    }
}

class _$InputItemSerializer implements PrimitiveSerializer<InputItem> {
  @override
  final Iterable<Type> types = const [InputItem, _$InputItem];

  @override
  final String wireName = r'InputItem';

  Iterable<Object?> _serializeProperties(
    Serializers serializers,
    InputItem object, {
    FullType specifiedType = FullType.unspecified,
  }) sync* {
  }

  @override
  Object serialize(
    Serializers serializers,
    InputItem object, {
    FullType specifiedType = FullType.unspecified,
  }) {
    final oneOf = object.oneOf;
    return serializers.serialize(oneOf.value, specifiedType: FullType(oneOf.valueType))!;
  }

  @override
  InputItem deserialize(
    Serializers serializers,
    Object serialized, {
    FullType specifiedType = FullType.unspecified,
  }) {
    final result = InputItemBuilder();
    Object? oneOfDataSrc;
    final serializedList = (serialized as Iterable<Object?>).toList();
    final discIndex = serializedList.indexOf(InputItem.discriminatorFieldName) + 1;
    final discValue = serializers.deserialize(serializedList[discIndex], specifiedType: FullType(String)) as String;
    oneOfDataSrc = serialized;
    final oneOfTypes = [EasyInputMessage, Item, ItemReferenceParam, ];
    Object oneOfResult;
    Type oneOfType;
    switch (discValue) {
      case r'EasyInputMessage':
        oneOfResult = serializers.deserialize(
          oneOfDataSrc,
          specifiedType: FullType(EasyInputMessage),
        ) as EasyInputMessage;
        oneOfType = EasyInputMessage;
        break;
      case r'Item':
        oneOfResult = serializers.deserialize(
          oneOfDataSrc,
          specifiedType: FullType(Item),
        ) as Item;
        oneOfType = Item;
        break;
      case r'ItemReferenceParam':
        oneOfResult = serializers.deserialize(
          oneOfDataSrc,
          specifiedType: FullType(ItemReferenceParam),
        ) as ItemReferenceParam;
        oneOfType = ItemReferenceParam;
        break;
      default:
        throw UnsupportedError("Couldn't deserialize oneOf for the discriminator value: ${discValue}");
    }
    result.oneOf = OneOfDynamic(typeIndex: oneOfTypes.indexOf(oneOfType), types: oneOfTypes, value: oneOfResult);
    return result.build();
  }
}

class InputItemRoleEnum extends EnumClass {

  /// The role of the output message. Always `assistant`. 
  @BuiltValueEnumConst(wireName: r'assistant')
  static const InputItemRoleEnum assistant = _$inputItemRoleEnum_assistant;

  static Serializer<InputItemRoleEnum> get serializer => _$inputItemRoleEnumSerializer;

  const InputItemRoleEnum._(String name): super(name);

  static BuiltSet<InputItemRoleEnum> get values => _$inputItemRoleEnumValues;
  static InputItemRoleEnum valueOf(String name) => _$inputItemRoleEnumValueOf(name);
}

class InputItemTypeEnum extends EnumClass {

  /// The type of the message input. Always `message`. 
  @BuiltValueEnumConst(wireName: r'message')
  static const InputItemTypeEnum message = _$inputItemTypeEnum_message;
  /// The type of the message input. Always `message`. 
  @BuiltValueEnumConst(wireName: r'mcp_call')
  static const InputItemTypeEnum mcpCall = _$inputItemTypeEnum_mcpCall;
  /// The type of the message input. Always `message`. 
  @BuiltValueEnumConst(wireName: r'item_reference')
  static const InputItemTypeEnum itemReference = _$inputItemTypeEnum_itemReference;

  static Serializer<InputItemTypeEnum> get serializer => _$inputItemTypeEnumSerializer;

  const InputItemTypeEnum._(String name): super(name);

  static BuiltSet<InputItemTypeEnum> get values => _$inputItemTypeEnumValues;
  static InputItemTypeEnum valueOf(String name) => _$inputItemTypeEnumValueOf(name);
}

class InputItemStatusEnum extends EnumClass {

  /// The status of the item. One of `in_progress`, `completed`, or `incomplete`. 
  @BuiltValueEnumConst(wireName: r'in_progress')
  static const InputItemStatusEnum inProgress = _$inputItemStatusEnum_inProgress;
  /// The status of the item. One of `in_progress`, `completed`, or `incomplete`. 
  @BuiltValueEnumConst(wireName: r'completed')
  static const InputItemStatusEnum completed = _$inputItemStatusEnum_completed;
  /// The status of the item. One of `in_progress`, `completed`, or `incomplete`. 
  @BuiltValueEnumConst(wireName: r'incomplete')
  static const InputItemStatusEnum incomplete = _$inputItemStatusEnum_incomplete;

  static Serializer<InputItemStatusEnum> get serializer => _$inputItemStatusEnumSerializer;

  const InputItemStatusEnum._(String name): super(name);

  static BuiltSet<InputItemStatusEnum> get values => _$inputItemStatusEnumValues;
  static InputItemStatusEnum valueOf(String name) => _$inputItemStatusEnumValueOf(name);
}

